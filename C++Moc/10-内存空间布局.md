## 写在前面
```
每个应用都有自己独立的内存空间--今天不会讲太多代码，主要是理论。
```
## 名词解释
```
每个应用都有自己独立的内存空间，其内存空间一般都有以下几大区域
栈空间，堆空间，代码区，全局区，其实我们主要关心的是堆区，因为我们的代码的声明周期都在堆区里完成。
```
|  名   称  | 说明 | 作用 |
| ------ | ------ | ------ |
| 堆空间 | 每调用一个函数就会给它分配一段连续的栈空间，等函数调用完毕后会自动回收这段栈空间 | 自动分配和回收 |
| 堆空间 | 需要主动去申请和释放 | 比如类的对象的创建 |
| 代码区 | 代码段(代码区) | 用于存放代码 |
| 全局区 | 数据段(全局区) | 用于存放全局变量等 |
## 码上建功 --堆空间 
```
在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存
堆空间的申请\释放
malloc \ free 
new \ delete
new [] \ delete []

是不是有点速度快，Java和OC中局可以使用new来初始化一个对象。
来看几个栗子
// 没有初始化
int *p1 = new int;
// 初始化为0
int *p2 = new int();
// 初始化为5
int *p3 = new int(5);
// 没有初始化
int *p4 = new int[3];
// 全部元素初始化为0
int *p5 = new int[3]();
// 全部元素初始化为0
int *p6 = new int[3]{};
// 首元素初始化为5，其他元素初始化为0
int *p7 = new int[3]{ 5 };

这样做有什么问题没，C++ 可没有ARC和GC管理机制
new 这么多的对象，肯定造成内存泄露了。
每new一次就要在不使用的时候销毁（delete），要成对出现
int *p = new int;
delete p;

```
## 码说 --栈空间 全局区
```
定义一个结构体
struct Person {
    int m_age;
};
// 全局区
Person g_person;
// 栈空间
Person person;
int main() {
    // 栈空间
    Person person;
    // 堆空间
    Person *p = new Person();
    p->m_age = 20;
    delete p;
    //举一个malloc的栗子
    Person *p2 = (Person *) malloc(sizeof(Person));
    free(p2);
}

```
## 装逼一下
```
申请堆空间成功后，会返回那一段内存空间的地址
申请和释放必须是1对1的关系，不然可能会存在内存泄露
现在的很多高级编程语言不需要开发人员去管理内存(比如Java)，屏蔽了很多内存细节，利弊同时存在
利:提高开发效率，避免内存使用不当或泄露
弊:不利于开发人员了解本质，永远停留在API调用和表层语法糖，对性能优化无从下手 --奸笑
```